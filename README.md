# Отчет по практической работе
## «Основы Git и визуализация кода на Go с помощью PlantUML»

**Студент:** Солнцев Глеб
**Группа:** БИСО-02-23
**Дата:** 15.02.2026

### 1. Используемые технологии
- **Git** — система контроля версий.
- **GitHub** — удаленный репозиторий.
- **PlantUML** — инструмент для создания UML-диаграмм.
- **Go** — язык программирования.

### 2. Выполненные задания

#### Этап 1: Создание Git-репозитория
Были выполнены следующие команды:
*   `git clone` — клонирование репозитория.
*   `git add .` — добавление файлов в staging area.
*   `git commit -m "Initial commit"` — создание первого коммита.

#### Этап 2: PlantUML и код на Go
Разработана диаграмма классов, описывающая паттерн "Стратегия" (или "Инъекция зависимости") для отправки уведомлений.

### 3. Ответы на контрольные вопросы

#### 1. Для чего нужна команда `git init, git clone`?

git init используется, когда есть папка с кодом на компьютере и мы хотим превратить её в Git-репозиторий, чтобы начать отслеживать изменения.
git clone используется, когда проект уже существует (например, на GitHub) и нам нужно скачать его себе.

#### 2. Что такое "коммит"?

Коммит — это фиксация изменений в истории проекта. Когда мы делаем коммит, Git делает «снимок» всех файлов в их текущем состоянии.

Вот что именно в него входит:

Уникальный ID: Это «имя» коммита, длинная строка из цифр и букв. Она вычисляется математически на основе всего содержимого. Если изменить хотя бы запятую в коде или одну букву в описании, ID будет уже другим.

Указатель на дерево: Git не копирует каждый раз все файлы заново, если они не менялись. Он создает список (дерево), где указано: «файл А остался прежним, а файл Б теперь выглядит вот так». Это делает Git очень быстрым и экономным.

Автор: тот, кто фактически написал код.

Коммитер: тот, кто зафиксировал это в репозитории

Временная метка: Точная дата и время создания сохранения с указанием часового пояса.

Сообщение: Свой добавочный текст, объясняющий смысл правок.

Ссылка на «родителя»: Каждый коммит знает, какой коммит был до него. Именно благодаря этим ссылкам выстраивается цепочка истории, по которой можно «отмотать» проект назад.

#### 3. Чем отличаются файлы `.puml` от `.png` в контексте вашей работы?

.puml - это текстовый файл с инструкциями для PlantUML. Он весит мало, его можно редактировать в любом текстовом редакторе, и он понятен человеку.
.png - это картинка, «отрендеренная» на основе .puml. Это просто набор пикселей. Если мы захотим изменить текст на стрелочке в PNG, нам придется перерисовывать всё заново в графическом редакторе.

В Git лучше хранить .puml и на это есть несколько причин:

Если мы изменим одну линию в диаграмме, в .puml Git покажет нам, например: «строка 10 изменилась». Мы четко увидим, что именно поменялось. В случае с .png Git просто скажет: «Бинарный файл изменился», и мы никак не узнаем, что именно там подправили, не открыв картинку глазами.

Бинарные файлы (.png, .jpg, .pdf) при каждом изменении сохраняются в Git целиком. Если у нас 100 итераций диаграммы, репозиторий станет очень много весить. Текстовый .puml почти не занимает места.

Если два человека одновременно поправят .puml, их правки можно объединить. Если два человека изменят .png, объединить их автоматически невозможно.

Храня код, мы всегда сможем сгенерировать из него актуальную картинку любой версии.

#### 4. Объясните, как в коде Go реализуется связь "класс User использует интерфейс Notifier", показанная на диаграмме.

Интерфейс Notifier:

type Notifier interface {
    Send(message string) error
}

Реализации:

type EmailNotifier struct {
	smtpHost string
	smtpPort int
}

type SmsNotifier struct {
	apiKey      string
	phoneNumber string
}

Связь «использует интерфейс» прописана в структуре UserGlebSolntsev:

type UserGlebSolntsev struct {
    name     string
    email    string
    notifier Notifier // — связь здесь
}

User получает нужную реализацию в момент создания (инициализации) объекта через функцию-конструктор:

func NewUserGlebSolntsev(name string, email string, notifier Notifier) *UserGlebSolntsev {
    return &UserGlebSolntsev{
        notifier: notifier, // - пробрасываем реализацию внутрь
    }
}